// Code generated by protoc-gen-go.
// source: idprovider.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// which way to unique a user
type SignUpType int32

const (
	SignUpType_EMAIL  SignUpType = 0
	SignUpType_MOBILE SignUpType = 1
)

var SignUpType_name = map[int32]string{
	0: "EMAIL",
	1: "MOBILE",
}
var SignUpType_value = map[string]int32{
	"EMAIL":  0,
	"MOBILE": 1,
}

func (x SignUpType) String() string {
	return proto.EnumName(SignUpType_name, int32(x))
}

// user type
type UserType int32

const (
	UserType_NORMAL       UserType = 0
	UserType_ORGANIZATION UserType = 1
)

var UserType_name = map[int32]string{
	0: "NORMAL",
	1: "ORGANIZATION",
}
var UserType_value = map[string]int32{
	"NORMAL":       0,
	"ORGANIZATION": 1,
}

func (x UserType) String() string {
	return proto.EnumName(UserType_name, int32(x))
}

// device for
type DeviceFor int32

const (
	DeviceFor_FARMER     DeviceFor = 0
	DeviceFor_LEDGER     DeviceFor = 1
	DeviceFor_TELLER     DeviceFor = 2
	DeviceFor_SUPERVISOR DeviceFor = 3
	DeviceFor_IDPROVIDER DeviceFor = 4
)

var DeviceFor_name = map[int32]string{
	0: "FARMER",
	1: "LEDGER",
	2: "TELLER",
	3: "SUPERVISOR",
	4: "IDPROVIDER",
}
var DeviceFor_value = map[string]int32{
	"FARMER":     0,
	"LEDGER":     1,
	"TELLER":     2,
	"SUPERVISOR": 3,
	"IDPROVIDER": 4,
}

func (x DeviceFor) String() string {
	return proto.EnumName(DeviceFor_name, int32(x))
}

// User class
// not for orm, just for easy code
type User struct {
	UserID   string    `protobuf:"bytes,1,opt,name=userID" json:"userID,omitempty"`
	Email    string    `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	Mobile   string    `protobuf:"bytes,3,opt,name=mobile" json:"mobile,omitempty"`
	Pass     string    `protobuf:"bytes,4,opt,name=pass" json:"pass,omitempty"`
	Nick     string    `protobuf:"bytes,5,opt,name=nick" json:"nick,omitempty"`
	UserType UserType  `protobuf:"varint,6,opt,name=userType,enum=protos.UserType" json:"userType,omitempty"`
	Wpub     []byte    `protobuf:"bytes,7,opt,name=wpub,proto3" json:"wpub,omitempty"`
	Spub     []byte    `protobuf:"bytes,8,opt,name=spub,proto3" json:"spub,omitempty"`
	Devices  []*Device `protobuf:"bytes,9,rep,name=devices" json:"devices,omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetDevices() []*Device {
	if m != nil {
		return m.Devices
	}
	return nil
}

// user device
type Device struct {
	UserID   string    `protobuf:"bytes,1,opt,name=userID" json:"userID,omitempty"`
	DeviceID string    `protobuf:"bytes,2,opt,name=deviceID" json:"deviceID,omitempty"`
	Os       string    `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	For      DeviceFor `protobuf:"varint,4,opt,name=for,enum=protos.DeviceFor" json:"for,omitempty"`
	Mac      string    `protobuf:"bytes,5,opt,name=mac" json:"mac,omitempty"`
	Alias    string    `protobuf:"bytes,6,opt,name=alias" json:"alias,omitempty"`
	Wpub     []byte    `protobuf:"bytes,7,opt,name=wpub,proto3" json:"wpub,omitempty"`
	Spub     []byte    `protobuf:"bytes,8,opt,name=spub,proto3" json:"spub,omitempty"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}

// idpp create certificate request
type IDPCertCreateReq struct {
	Ts     int64  `protobuf:"varint,1,opt,name=ts" json:"ts,omitempty"`
	Id     string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	PubKey []byte `protobuf:"bytes,3,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
	Sig    []byte `protobuf:"bytes,4,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *IDPCertCreateReq) Reset()         { *m = IDPCertCreateReq{} }
func (m *IDPCertCreateReq) String() string { return proto.CompactTextString(m) }
func (*IDPCertCreateReq) ProtoMessage()    {}

type IDPCertCreateRsp struct {
	Error    *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Cert     []byte `protobuf:"bytes,2,opt,name=cert,proto3" json:"cert,omitempty"`
	Rootcert []byte `protobuf:"bytes,3,opt,name=rootcert,proto3" json:"rootcert,omitempty"`
}

func (m *IDPCertCreateRsp) Reset()         { *m = IDPCertCreateRsp{} }
func (m *IDPCertCreateRsp) String() string { return proto.CompactTextString(m) }
func (*IDPCertCreateRsp) ProtoMessage()    {}

func (m *IDPCertCreateRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

// AcquireCaptchaReq holds request
type AcquireCaptchaReq struct {
	SignUpType SignUpType `protobuf:"varint,1,opt,name=signUpType,enum=protos.SignUpType" json:"signUpType,omitempty"`
	SignUp     string     `protobuf:"bytes,2,opt,name=signUp" json:"signUp,omitempty"`
}

func (m *AcquireCaptchaReq) Reset()         { *m = AcquireCaptchaReq{} }
func (m *AcquireCaptchaReq) String() string { return proto.CompactTextString(m) }
func (*AcquireCaptchaReq) ProtoMessage()    {}

type AcquireCaptchaRsp struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *AcquireCaptchaRsp) Reset()         { *m = AcquireCaptchaRsp{} }
func (m *AcquireCaptchaRsp) String() string { return proto.CompactTextString(m) }
func (*AcquireCaptchaRsp) ProtoMessage()    {}

func (m *AcquireCaptchaRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type VerifyCaptchaReq struct {
	SignUpType SignUpType `protobuf:"varint,1,opt,name=signUpType,enum=protos.SignUpType" json:"signUpType,omitempty"`
	SignUp     string     `protobuf:"bytes,2,opt,name=signUp" json:"signUp,omitempty"`
	Captcha    string     `protobuf:"bytes,3,opt,name=captcha" json:"captcha,omitempty"`
}

func (m *VerifyCaptchaReq) Reset()         { *m = VerifyCaptchaReq{} }
func (m *VerifyCaptchaReq) String() string { return proto.CompactTextString(m) }
func (*VerifyCaptchaReq) ProtoMessage()    {}

type VerifyCaptchaRsp struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *VerifyCaptchaRsp) Reset()         { *m = VerifyCaptchaRsp{} }
func (m *VerifyCaptchaRsp) String() string { return proto.CompactTextString(m) }
func (*VerifyCaptchaRsp) ProtoMessage()    {}

func (m *VerifyCaptchaRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type RegisterUserReq struct {
	SignUpType SignUpType `protobuf:"varint,1,opt,name=signUpType,enum=protos.SignUpType" json:"signUpType,omitempty"`
	SignUp     string     `protobuf:"bytes,2,opt,name=signUp" json:"signUp,omitempty"`
	Nick       string     `protobuf:"bytes,3,opt,name=nick" json:"nick,omitempty"`
	Pass       string     `protobuf:"bytes,4,opt,name=pass" json:"pass,omitempty"`
	Wpub       []byte     `protobuf:"bytes,5,opt,name=wpub,proto3" json:"wpub,omitempty"`
	Spub       []byte     `protobuf:"bytes,6,opt,name=spub,proto3" json:"spub,omitempty"`
	Sign       []byte     `protobuf:"bytes,7,opt,name=sign,proto3" json:"sign,omitempty"`
	UserType   UserType   `protobuf:"varint,8,opt,name=userType,enum=protos.UserType" json:"userType,omitempty"`
}

func (m *RegisterUserReq) Reset()         { *m = RegisterUserReq{} }
func (m *RegisterUserReq) String() string { return proto.CompactTextString(m) }
func (*RegisterUserReq) ProtoMessage()    {}

type RegisterUserRsp struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	User  *User  `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *RegisterUserRsp) Reset()         { *m = RegisterUserRsp{} }
func (m *RegisterUserRsp) String() string { return proto.CompactTextString(m) }
func (*RegisterUserRsp) ProtoMessage()    {}

func (m *RegisterUserRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *RegisterUserRsp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type BindDeviceReq struct {
	UserID string    `protobuf:"bytes,1,opt,name=userID" json:"userID,omitempty"`
	Os     string    `protobuf:"bytes,2,opt,name=os" json:"os,omitempty"`
	For    DeviceFor `protobuf:"varint,3,opt,name=for,enum=protos.DeviceFor" json:"for,omitempty"`
	Mac    string    `protobuf:"bytes,4,opt,name=mac" json:"mac,omitempty"`
	Alias  string    `protobuf:"bytes,5,opt,name=alias" json:"alias,omitempty"`
	// device wallet public key
	Wpub []byte `protobuf:"bytes,6,opt,name=wpub,proto3" json:"wpub,omitempty"`
	// device signature public key
	Spub []byte `protobuf:"bytes,7,opt,name=spub,proto3" json:"spub,omitempty"`
	// request signature, though has spub, but using user's spub signature this message, dont forget!
	Sign []byte `protobuf:"bytes,8,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *BindDeviceReq) Reset()         { *m = BindDeviceReq{} }
func (m *BindDeviceReq) String() string { return proto.CompactTextString(m) }
func (*BindDeviceReq) ProtoMessage()    {}

type BindDeviceRsp struct {
	Error  *Error  `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Device *Device `protobuf:"bytes,2,opt,name=device" json:"device,omitempty"`
}

func (m *BindDeviceRsp) Reset()         { *m = BindDeviceRsp{} }
func (m *BindDeviceRsp) String() string { return proto.CompactTextString(m) }
func (*BindDeviceRsp) ProtoMessage()    {}

func (m *BindDeviceRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BindDeviceRsp) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

type VerifyDeviceReq struct {
	DeviceID    string    `protobuf:"bytes,1,opt,name=deviceID" json:"deviceID,omitempty"`
	For         DeviceFor `protobuf:"varint,2,opt,name=for,enum=protos.DeviceFor" json:"for,omitempty"`
	UserID      string    `protobuf:"bytes,3,opt,name=userID" json:"userID,omitempty"`
	DeviceAlias string    `protobuf:"bytes,4,opt,name=deviceAlias" json:"deviceAlias,omitempty"`
}

func (m *VerifyDeviceReq) Reset()         { *m = VerifyDeviceReq{} }
func (m *VerifyDeviceReq) String() string { return proto.CompactTextString(m) }
func (*VerifyDeviceReq) ProtoMessage()    {}

type VerifyDeviceRsp struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *VerifyDeviceRsp) Reset()         { *m = VerifyDeviceRsp{} }
func (m *VerifyDeviceRsp) String() string { return proto.CompactTextString(m) }
func (*VerifyDeviceRsp) ProtoMessage()    {}

func (m *VerifyDeviceRsp) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.SignUpType", SignUpType_name, SignUpType_value)
	proto.RegisterEnum("protos.UserType", UserType_name, UserType_value)
	proto.RegisterEnum("protos.DeviceFor", DeviceFor_name, DeviceFor_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for IDPP service

type IDPPClient interface {
	// Acquire email/tel captcha
	AcquireCaptcha(ctx context.Context, in *AcquireCaptchaReq, opts ...grpc.CallOption) (*AcquireCaptchaRsp, error)
	// Verify email/tel captcha
	VerifyCaptcha(ctx context.Context, in *VerifyCaptchaReq, opts ...grpc.CallOption) (*VerifyCaptchaRsp, error)
	// Register a user
	RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...grpc.CallOption) (*RegisterUserRsp, error)
	// Bind a device for a user
	BindDeviceForUser(ctx context.Context, in *BindDeviceReq, opts ...grpc.CallOption) (*BindDeviceRsp, error)
}

type iDPPClient struct {
	cc *grpc.ClientConn
}

func NewIDPPClient(cc *grpc.ClientConn) IDPPClient {
	return &iDPPClient{cc}
}

func (c *iDPPClient) AcquireCaptcha(ctx context.Context, in *AcquireCaptchaReq, opts ...grpc.CallOption) (*AcquireCaptchaRsp, error) {
	out := new(AcquireCaptchaRsp)
	err := grpc.Invoke(ctx, "/protos.IDPP/AcquireCaptcha", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iDPPClient) VerifyCaptcha(ctx context.Context, in *VerifyCaptchaReq, opts ...grpc.CallOption) (*VerifyCaptchaRsp, error) {
	out := new(VerifyCaptchaRsp)
	err := grpc.Invoke(ctx, "/protos.IDPP/VerifyCaptcha", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iDPPClient) RegisterUser(ctx context.Context, in *RegisterUserReq, opts ...grpc.CallOption) (*RegisterUserRsp, error) {
	out := new(RegisterUserRsp)
	err := grpc.Invoke(ctx, "/protos.IDPP/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iDPPClient) BindDeviceForUser(ctx context.Context, in *BindDeviceReq, opts ...grpc.CallOption) (*BindDeviceRsp, error) {
	out := new(BindDeviceRsp)
	err := grpc.Invoke(ctx, "/protos.IDPP/BindDeviceForUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IDPP service

type IDPPServer interface {
	// Acquire email/tel captcha
	AcquireCaptcha(context.Context, *AcquireCaptchaReq) (*AcquireCaptchaRsp, error)
	// Verify email/tel captcha
	VerifyCaptcha(context.Context, *VerifyCaptchaReq) (*VerifyCaptchaRsp, error)
	// Register a user
	RegisterUser(context.Context, *RegisterUserReq) (*RegisterUserRsp, error)
	// Bind a device for a user
	BindDeviceForUser(context.Context, *BindDeviceReq) (*BindDeviceRsp, error)
}

func RegisterIDPPServer(s *grpc.Server, srv IDPPServer) {
	s.RegisterService(&_IDPP_serviceDesc, srv)
}

func _IDPP_AcquireCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AcquireCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IDPPServer).AcquireCaptcha(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _IDPP_VerifyCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VerifyCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IDPPServer).VerifyCaptcha(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _IDPP_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisterUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IDPPServer).RegisterUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _IDPP_BindDeviceForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BindDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IDPPServer).BindDeviceForUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _IDPP_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.IDPP",
	HandlerType: (*IDPPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AcquireCaptcha",
			Handler:    _IDPP_AcquireCaptcha_Handler,
		},
		{
			MethodName: "VerifyCaptcha",
			Handler:    _IDPP_VerifyCaptcha_Handler,
		},
		{
			MethodName: "RegisterUser",
			Handler:    _IDPP_RegisterUser_Handler,
		},
		{
			MethodName: "BindDeviceForUser",
			Handler:    _IDPP_BindDeviceForUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for IDPA service

type IDPAClient interface {
	// Verify device
	VerifyDevice(ctx context.Context, in *VerifyDeviceReq, opts ...grpc.CallOption) (*VerifyDeviceRsp, error)
}

type iDPAClient struct {
	cc *grpc.ClientConn
}

func NewIDPAClient(cc *grpc.ClientConn) IDPAClient {
	return &iDPAClient{cc}
}

func (c *iDPAClient) VerifyDevice(ctx context.Context, in *VerifyDeviceReq, opts ...grpc.CallOption) (*VerifyDeviceRsp, error) {
	out := new(VerifyDeviceRsp)
	err := grpc.Invoke(ctx, "/protos.IDPA/VerifyDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IDPA service

type IDPAServer interface {
	// Verify device
	VerifyDevice(context.Context, *VerifyDeviceReq) (*VerifyDeviceRsp, error)
}

func RegisterIDPAServer(s *grpc.Server, srv IDPAServer) {
	s.RegisterService(&_IDPA_serviceDesc, srv)
}

func _IDPA_VerifyDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VerifyDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IDPAServer).VerifyDevice(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _IDPA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.IDPA",
	HandlerType: (*IDPAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VerifyDevice",
			Handler:    _IDPA_VerifyDevice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
